# Задача 2. Декораторы

* **Дедлайн**: 17.10.2024, 23:59
* Полный балл: 15

## Задача

- [ ] Частичное применение (каррирование, curry) --- это превращение функции от нескольких параметров в функцию от одного параметра,
возвращающую функцию от остальных параметров. К ней существует обратная операция --- uncarry.
В Python каррирование в таком виде затруднено из-за произвольной арности.
Напишите функцию `curry_explicit(function, arity)` и парную к ней `uncurry_explicit(function, arity)`.
- Требования/допущения:
  - [ ] Если пользователь ошибся при указании арности, то бросить исключение.
  Можно [здесь](https://docs.python.org/3/tutorial/errors.html) посмотреть что это и как с этим работать.
  Здесь имеется в виду отслеживание простых ситуаций вида: пользователь указал, что функция от 1 аргумента,
  а передает 5 или же передает аргументы и указывает, что арность --- ноль.
  НЕ требуется проверки, действительно ли передана функция от трех аргументов, если передали арность = 3.
  - [ ] Отрицательная арность невозможна --- бросить исключение
  - [ ] При арности 0 результатом будет функция от 0 параметров: `curry_explicit(f,0)() == f()`
  - [ ] При арности 1 --- функция от 1 параметра: `curry_explicit(f,1)(x) == f(x)`
  - [ ] Не забудьте, что есть произвольно-арные функции, такие как print(); curry_explicit должна замораживать их арность,
  т.е. нельзя написать `curry_explicit(print,2)(1)(2)(3,4,5)`.
  В данном случае `curry_explicit(print,2)(1)(2)` вернет `None`,
  что сделает невозможным дальнейшее применение (Python сам бросит ошибку, данный кейс отдельно обрабатывать не нужно)
  - [ ] Именованные аргументы поддерживать не нужно
- Пример работы:
    ```python
    f2 = curry_explicit((lambda x, y, z: f'<{x},{y}, {z}>'), 3)
    g2 = uncurry_explicit(f2, 3)
    print(f2(123)(456)(562))
    print(g2(123, 456, 562))
    ________
    <123,456,562>
    <123,456,562>
    ```
-----
- [ ] Реализовать декоратор для кеширования результатов выполнения функции.
То есть необходимо сохранять результаты вычислений для разного набора аргументов функции.
Аргумент декоратора – сколько последних результатов хранить.
По умолчанию ничего не кэшируется. Необходимо поддержать как неименованные аргументы, так и именованные.
-----
- [ ] Напишите декоратор `@smart_args`, который анализирует типы значений по умолчанию аргументов функции и,
в зависимости от этого, копирует и/или вычисляет их перед выполнением функции:
  - `Evaluated(func_without_args)` --- подставляет значение по умолчанию, вычисляемое в момент вызова.
  В качестве аргумента принимает функцию БЕЗ аргументов, которая что-то возвращает.
  Например, она может менять глобальный счетчик или что-то считать внутри класса.
  Во время работы необходимо вызвать эту функцию и использовать значение, которое будет получено в результате выполнения.
  - `Isolated()` --- это фиктивное значение по умолчанию; аргумент должен быть передан, но в момент передачи - скопирован (глубокая копия).
  - Также необходимо реализовать сами `Evaluated` и `Isolated`.
- Требования\допущения:
  - [ ] Необходима поддержка только именованных аргументов
  - [ ] Не нужно сочетать `Isolated` и `Evaluated`
  - [ ] Добавьте проверки (assert) того, что пользователь случайно не вышел за эти рамки
  (использует `Isolated` и `Evaluated` в сочетании или пытается их использовать для позиционных аргументов)
- Пример работы `Isolated`:
    ```python
    @smart_args
    def check_isolation(*, d=Isolated()):
      d['a'] = 0
      return d

    no_mutable = {'a': 10}

    print(check_isolation(d=no_mutable))
    print(no_mutable)
    ________
    {'a': 0}
    {'a': 10}
    ```
- Пример работы `Evaluated` *(так как генерируется случайное число, то запуск на вашем компьютере может отличаться, но все числа в первой колонке ВСЕГДА будут одинаковыми)*:
    ```python
    import random

    def get_random_number():
       return random.randint(0,100)

    # Для x дефолтное значение всегда будет одинаковое, оно вычислится один раз
    # Для y дефолтное значение может быть разным, так как оно будет
    # вычисляться КАЖДЫЙ раз, если не передано значение y
    @smart_args
    def check_evaluation(*, x=get_random_number(), y=Evaluated(get_random_number)):
       print(x, y)


    check_evaluation()
    check_evaluation()
    check_evaluation(y=150)
    ________
    15 36
    15 66
    15 150
    ```
- [ ] **(Доп., +5 баллов)** Добавить поддержку позиционных аргументов (необходимо разобраться с `inspect.getfullargspec()`).
В таком случае необходимо добавить настройку для декоратора - возможность отключить данную функциональность.
